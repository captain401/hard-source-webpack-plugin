'use strict';

const pluginCompat = require('./util/plugin-compat');
const relateContext = require('./util/relate-context');
const { parityCacheFromCache, pushParityWriteOps } = require('./util/parity');

const relateNormalPath = relateContext.relateNormalPath;

function relateNormalRequest(compiler, key) {
  return key.split('!').map(subkey => relateNormalPath(compiler, subkey)).join('!');
}

function relateNormalModuleId(compiler, id) {
  return id.substring(0, 24) + relateNormalRequest(compiler, id.substring(24));
}

class ModuleCache {
  apply(compiler) {
    const compilerHooks = pluginCompat.hooks(compiler);

    let moduleCache = {};
    let parityCache = {};

    const moduleArchetypeCache = {
      _ops: [],

      get(id) {
        if (moduleCache[id] && !moduleCache[id].invalid) {
          if (typeof moduleCache[id] === 'string') {
            moduleCache[id] = JSON.parse(moduleCache[id]);
          }
          return moduleCache[id];
        }
      },

      set(id, item) {
        moduleCache[id] = item;
        if (item) {
          this._ops.push(id);
        } else if (moduleCache[id]) {
          if (typeof moduleCache[id] === 'string') {
            moduleCache[id] = JSON.parse(moduleCache[id]);
          }
          moduleCache[id].invalid = true;
          moduleCache[id].invalidReason = 'overwritten';

          this._ops.push(id);
        }
      },

      operations() {
        const _this = this;
        const ops = this._ops.map(id => ({
          key: relateNormalModuleId(compiler, id),
          value: _this.get(id) || null
        }));
        this._ops.length = 0;
        return ops;
      }
    };

    compilerHooks._hardSourceArchetypeRegister.call('Module', moduleArchetypeCache);

    let moduleCacheSerializer;

    compilerHooks._hardSourceCreateSerializer.tap('HardSource - ModuleCache', (cacheSerializerFactory, cacheDirPath) => {
      moduleCacheSerializer = cacheSerializerFactory.create({
        name: 'module',
        type: 'data',
        cacheDirPath,
        autoParse: true
      });
    });

    compilerHooks._hardSourceResetCache.tap('HardSource - ModuleCache', () => {
      moduleCache = {};
    });

    compilerHooks._hardSourceReadCache.tapPromise('HardSource - ModuleCache', ({ contextKeys, contextNormalModuleId, copyWithDeser }) => moduleCacheSerializer.read().then(_moduleCache => {
      Object.keys(_moduleCache).forEach(key => {
        if (key.startsWith('__hardSource_parityToken')) {
          parityCache[key] = _moduleCache[key];
          delete _moduleCache[key];
        }
      });
      return _moduleCache;
    }).then(contextKeys(compiler, contextNormalModuleId)).then(copyWithDeser.bind(null, moduleCache)));

    compilerHooks._hardSourceParityCache.tap('HardSource - ModuleCache', parityRoot => {
      parityCacheFromCache('Module', parityRoot, parityCache);
    });

    compilerHooks.compilation.tap('HardSource - ModuleCache', compilation => {
      compilation.__hardSourceModuleCache = moduleCache;
    });

    compilerHooks._hardSourceWriteCache.tapPromise('HardSource - ModuleCache', compilation => {
      const moduleOps = moduleArchetypeCache.operations();

      if (!compilation.compiler.parentCompilation) {
        // Add ops to remove no longer valid modules. If they were replaced with a
        // up to date module, they will already have replaced this item so we
        // won't accidentally delete up to date modules.
        Object.keys(moduleCache).forEach(key => {
          const cacheItem = moduleCache[key];
          if (cacheItem && cacheItem.invalid) {
            // console.log('invalid', cacheItem.invalidReason);
            moduleCache[key] = null;
            moduleOps.push({
              key,
              value: null
            });
          }
        });
      }

      pushParityWriteOps(compilation, moduleOps);

      return moduleCacheSerializer.write(moduleOps);
    });
  }
}

module.exports = ModuleCache;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhhcmQtc291cmNlLXdlYnBhY2stcGx1Z2luL2xpYi9DYWNoZU1vZHVsZS5qcyJdLCJuYW1lcyI6WyJwbHVnaW5Db21wYXQiLCJyZXF1aXJlIiwicmVsYXRlQ29udGV4dCIsInBhcml0eUNhY2hlRnJvbUNhY2hlIiwicHVzaFBhcml0eVdyaXRlT3BzIiwicmVsYXRlTm9ybWFsUGF0aCIsInJlbGF0ZU5vcm1hbFJlcXVlc3QiLCJjb21waWxlciIsImtleSIsInNwbGl0IiwibWFwIiwic3Via2V5Iiwiam9pbiIsInJlbGF0ZU5vcm1hbE1vZHVsZUlkIiwiaWQiLCJzdWJzdHJpbmciLCJNb2R1bGVDYWNoZSIsImFwcGx5IiwiY29tcGlsZXJIb29rcyIsImhvb2tzIiwibW9kdWxlQ2FjaGUiLCJwYXJpdHlDYWNoZSIsIm1vZHVsZUFyY2hldHlwZUNhY2hlIiwiX29wcyIsImdldCIsImludmFsaWQiLCJKU09OIiwicGFyc2UiLCJzZXQiLCJpdGVtIiwicHVzaCIsImludmFsaWRSZWFzb24iLCJvcGVyYXRpb25zIiwiX3RoaXMiLCJvcHMiLCJ2YWx1ZSIsImxlbmd0aCIsIl9oYXJkU291cmNlQXJjaGV0eXBlUmVnaXN0ZXIiLCJjYWxsIiwibW9kdWxlQ2FjaGVTZXJpYWxpemVyIiwiX2hhcmRTb3VyY2VDcmVhdGVTZXJpYWxpemVyIiwidGFwIiwiY2FjaGVTZXJpYWxpemVyRmFjdG9yeSIsImNhY2hlRGlyUGF0aCIsImNyZWF0ZSIsIm5hbWUiLCJ0eXBlIiwiYXV0b1BhcnNlIiwiX2hhcmRTb3VyY2VSZXNldENhY2hlIiwiX2hhcmRTb3VyY2VSZWFkQ2FjaGUiLCJ0YXBQcm9taXNlIiwiY29udGV4dEtleXMiLCJjb250ZXh0Tm9ybWFsTW9kdWxlSWQiLCJjb3B5V2l0aERlc2VyIiwicmVhZCIsInRoZW4iLCJfbW9kdWxlQ2FjaGUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInN0YXJ0c1dpdGgiLCJiaW5kIiwiX2hhcmRTb3VyY2VQYXJpdHlDYWNoZSIsInBhcml0eVJvb3QiLCJjb21waWxhdGlvbiIsIl9faGFyZFNvdXJjZU1vZHVsZUNhY2hlIiwiX2hhcmRTb3VyY2VXcml0ZUNhY2hlIiwibW9kdWxlT3BzIiwicGFyZW50Q29tcGlsYXRpb24iLCJjYWNoZUl0ZW0iLCJ3cml0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTUEsZUFBZUMsK0JBQXJCO0FBQ0EsTUFBTUMsZ0JBQWdCRCxnQ0FBdEI7QUFDQSxNQUFNLEVBQUVFLG9CQUFGLEVBQXdCQyxrQkFBeEIsS0FBK0NILHdCQUFyRDs7QUFFQSxNQUFNSSxtQkFBbUJILGNBQWNHLGdCQUF2Qzs7QUFFQSxTQUFTQyxtQkFBVCxDQUE2QkMsUUFBN0IsRUFBdUNDLEdBQXZDLEVBQTRDO0FBQzFDLFNBQU9BLElBQ0pDLEtBREksQ0FDRSxHQURGLEVBRUpDLEdBRkksQ0FFQUMsVUFBVU4saUJBQWlCRSxRQUFqQixFQUEyQkksTUFBM0IsQ0FGVixFQUdKQyxJQUhJLENBR0MsR0FIRCxDQUFQO0FBSUQ7O0FBRUQsU0FBU0Msb0JBQVQsQ0FBOEJOLFFBQTlCLEVBQXdDTyxFQUF4QyxFQUE0QztBQUMxQyxTQUFPQSxHQUFHQyxTQUFILENBQWEsQ0FBYixFQUFnQixFQUFoQixJQUFzQlQsb0JBQW9CQyxRQUFwQixFQUE4Qk8sR0FBR0MsU0FBSCxDQUFhLEVBQWIsQ0FBOUIsQ0FBN0I7QUFDRDs7QUFFRCxNQUFNQyxXQUFOLENBQWtCO0FBQ2hCQyxRQUFNVixRQUFOLEVBQWdCO0FBQ2QsVUFBTVcsZ0JBQWdCbEIsYUFBYW1CLEtBQWIsQ0FBbUJaLFFBQW5CLENBQXRCOztBQUVBLFFBQUlhLGNBQWMsRUFBbEI7QUFDQSxRQUFJQyxjQUFjLEVBQWxCOztBQUVBLFVBQU1DLHVCQUF1QjtBQUMzQkMsWUFBTSxFQURxQjs7QUFHM0JDLFVBQUlWLEVBQUosRUFBUTtBQUNOLFlBQUlNLFlBQVlOLEVBQVosS0FBbUIsQ0FBQ00sWUFBWU4sRUFBWixFQUFnQlcsT0FBeEMsRUFBaUQ7QUFDL0MsY0FBSSxPQUFPTCxZQUFZTixFQUFaLENBQVAsS0FBMkIsUUFBL0IsRUFBeUM7QUFDdkNNLHdCQUFZTixFQUFaLElBQWtCWSxLQUFLQyxLQUFMLENBQVdQLFlBQVlOLEVBQVosQ0FBWCxDQUFsQjtBQUNEO0FBQ0QsaUJBQU9NLFlBQVlOLEVBQVosQ0FBUDtBQUNEO0FBQ0YsT0FWMEI7O0FBWTNCYyxVQUFJZCxFQUFKLEVBQVFlLElBQVIsRUFBYztBQUNaVCxvQkFBWU4sRUFBWixJQUFrQmUsSUFBbEI7QUFDQSxZQUFJQSxJQUFKLEVBQVU7QUFDUixlQUFLTixJQUFMLENBQVVPLElBQVYsQ0FBZWhCLEVBQWY7QUFDRCxTQUZELE1BRU8sSUFBSU0sWUFBWU4sRUFBWixDQUFKLEVBQXFCO0FBQzFCLGNBQUksT0FBT00sWUFBWU4sRUFBWixDQUFQLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDTSx3QkFBWU4sRUFBWixJQUFrQlksS0FBS0MsS0FBTCxDQUFXUCxZQUFZTixFQUFaLENBQVgsQ0FBbEI7QUFDRDtBQUNETSxzQkFBWU4sRUFBWixFQUFnQlcsT0FBaEIsR0FBMEIsSUFBMUI7QUFDQUwsc0JBQVlOLEVBQVosRUFBZ0JpQixhQUFoQixHQUFnQyxhQUFoQzs7QUFFQSxlQUFLUixJQUFMLENBQVVPLElBQVYsQ0FBZWhCLEVBQWY7QUFDRDtBQUNGLE9BekIwQjs7QUEyQjNCa0IsbUJBQWE7QUFDWCxjQUFNQyxRQUFRLElBQWQ7QUFDQSxjQUFNQyxNQUFNLEtBQUtYLElBQUwsQ0FBVWIsR0FBVixDQUFjSSxPQUFPO0FBQy9CTixlQUFLSyxxQkFBcUJOLFFBQXJCLEVBQStCTyxFQUEvQixDQUQwQjtBQUUvQnFCLGlCQUFPRixNQUFNVCxHQUFOLENBQVVWLEVBQVYsS0FBaUI7QUFGTyxTQUFQLENBQWQsQ0FBWjtBQUlBLGFBQUtTLElBQUwsQ0FBVWEsTUFBVixHQUFtQixDQUFuQjtBQUNBLGVBQU9GLEdBQVA7QUFDRDtBQW5DMEIsS0FBN0I7O0FBc0NBaEIsa0JBQWNtQiw0QkFBZCxDQUEyQ0MsSUFBM0MsQ0FDRSxRQURGLEVBRUVoQixvQkFGRjs7QUFLQSxRQUFJaUIscUJBQUo7O0FBRUFyQixrQkFBY3NCLDJCQUFkLENBQTBDQyxHQUExQyxDQUNFLDBCQURGLEVBRUUsQ0FBQ0Msc0JBQUQsRUFBeUJDLFlBQXpCLEtBQTBDO0FBQ3hDSiw4QkFBd0JHLHVCQUF1QkUsTUFBdkIsQ0FBOEI7QUFDcERDLGNBQU0sUUFEOEM7QUFFcERDLGNBQU0sTUFGOEM7QUFHcERILG9CQUhvRDtBQUlwREksbUJBQVc7QUFKeUMsT0FBOUIsQ0FBeEI7QUFNRCxLQVRIOztBQVlBN0Isa0JBQWM4QixxQkFBZCxDQUFvQ1AsR0FBcEMsQ0FBd0MsMEJBQXhDLEVBQW9FLE1BQU07QUFDeEVyQixvQkFBYyxFQUFkO0FBQ0QsS0FGRDs7QUFJQUYsa0JBQWMrQixvQkFBZCxDQUFtQ0MsVUFBbkMsQ0FDRSwwQkFERixFQUVFLENBQUMsRUFBRUMsV0FBRixFQUFlQyxxQkFBZixFQUFzQ0MsYUFBdEMsRUFBRCxLQUNFZCxzQkFDR2UsSUFESCxHQUVHQyxJQUZILENBRVFDLGdCQUFnQjtBQUNwQkMsYUFBT0MsSUFBUCxDQUFZRixZQUFaLEVBQTBCRyxPQUExQixDQUFrQ25ELE9BQU87QUFDdkMsWUFBSUEsSUFBSW9ELFVBQUosQ0FBZSwwQkFBZixDQUFKLEVBQWdEO0FBQzlDdkMsc0JBQVliLEdBQVosSUFBbUJnRCxhQUFhaEQsR0FBYixDQUFuQjtBQUNBLGlCQUFPZ0QsYUFBYWhELEdBQWIsQ0FBUDtBQUNEO0FBQ0YsT0FMRDtBQU1BLGFBQU9nRCxZQUFQO0FBQ0QsS0FWSCxFQVdHRCxJQVhILENBV1FKLFlBQVk1QyxRQUFaLEVBQXNCNkMscUJBQXRCLENBWFIsRUFZR0csSUFaSCxDQVlRRixjQUFjUSxJQUFkLENBQW1CLElBQW5CLEVBQXlCekMsV0FBekIsQ0FaUixDQUhKOztBQWtCQUYsa0JBQWM0QyxzQkFBZCxDQUFxQ3JCLEdBQXJDLENBQ0UsMEJBREYsRUFFRXNCLGNBQWM7QUFDWjVELDJCQUFxQixRQUFyQixFQUErQjRELFVBQS9CLEVBQTJDMUMsV0FBM0M7QUFDRCxLQUpIOztBQU9BSCxrQkFBYzhDLFdBQWQsQ0FBMEJ2QixHQUExQixDQUE4QiwwQkFBOUIsRUFBMER1QixlQUFlO0FBQ3ZFQSxrQkFBWUMsdUJBQVosR0FBc0M3QyxXQUF0QztBQUNELEtBRkQ7O0FBSUFGLGtCQUFjZ0QscUJBQWQsQ0FBb0NoQixVQUFwQyxDQUNFLDBCQURGLEVBRUVjLGVBQWU7QUFDYixZQUFNRyxZQUFZN0MscUJBQXFCVSxVQUFyQixFQUFsQjs7QUFFQSxVQUFJLENBQUNnQyxZQUFZekQsUUFBWixDQUFxQjZELGlCQUExQixFQUE2QztBQUMzQztBQUNBO0FBQ0E7QUFDQVgsZUFBT0MsSUFBUCxDQUFZdEMsV0FBWixFQUF5QnVDLE9BQXpCLENBQWlDbkQsT0FBTztBQUN0QyxnQkFBTTZELFlBQVlqRCxZQUFZWixHQUFaLENBQWxCO0FBQ0EsY0FBSTZELGFBQWFBLFVBQVU1QyxPQUEzQixFQUFvQztBQUNsQztBQUNBTCx3QkFBWVosR0FBWixJQUFtQixJQUFuQjtBQUNBMkQsc0JBQVVyQyxJQUFWLENBQWU7QUFDYnRCLGlCQURhO0FBRWIyQixxQkFBTztBQUZNLGFBQWY7QUFJRDtBQUNGLFNBVkQ7QUFXRDs7QUFFRC9CLHlCQUFtQjRELFdBQW5CLEVBQWdDRyxTQUFoQzs7QUFFQSxhQUFPNUIsc0JBQXNCK0IsS0FBdEIsQ0FBNEJILFNBQTVCLENBQVA7QUFDRCxLQXpCSDtBQTJCRDtBQTVIZTs7QUErSGxCSSxPQUFPQyxPQUFQLEdBQWlCeEQsV0FBakIiLCJmaWxlIjoiaGFyZC1zb3VyY2Utd2VicGFjay1wbHVnaW4vbGliL0NhY2hlTW9kdWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGx1Z2luQ29tcGF0ID0gcmVxdWlyZSgnLi91dGlsL3BsdWdpbi1jb21wYXQnKTtcbmNvbnN0IHJlbGF0ZUNvbnRleHQgPSByZXF1aXJlKCcuL3V0aWwvcmVsYXRlLWNvbnRleHQnKTtcbmNvbnN0IHsgcGFyaXR5Q2FjaGVGcm9tQ2FjaGUsIHB1c2hQYXJpdHlXcml0ZU9wcyB9ID0gcmVxdWlyZSgnLi91dGlsL3Bhcml0eScpO1xuXG5jb25zdCByZWxhdGVOb3JtYWxQYXRoID0gcmVsYXRlQ29udGV4dC5yZWxhdGVOb3JtYWxQYXRoO1xuXG5mdW5jdGlvbiByZWxhdGVOb3JtYWxSZXF1ZXN0KGNvbXBpbGVyLCBrZXkpIHtcbiAgcmV0dXJuIGtleVxuICAgIC5zcGxpdCgnIScpXG4gICAgLm1hcChzdWJrZXkgPT4gcmVsYXRlTm9ybWFsUGF0aChjb21waWxlciwgc3Via2V5KSlcbiAgICAuam9pbignIScpO1xufVxuXG5mdW5jdGlvbiByZWxhdGVOb3JtYWxNb2R1bGVJZChjb21waWxlciwgaWQpIHtcbiAgcmV0dXJuIGlkLnN1YnN0cmluZygwLCAyNCkgKyByZWxhdGVOb3JtYWxSZXF1ZXN0KGNvbXBpbGVyLCBpZC5zdWJzdHJpbmcoMjQpKTtcbn1cblxuY2xhc3MgTW9kdWxlQ2FjaGUge1xuICBhcHBseShjb21waWxlcikge1xuICAgIGNvbnN0IGNvbXBpbGVySG9va3MgPSBwbHVnaW5Db21wYXQuaG9va3MoY29tcGlsZXIpO1xuXG4gICAgbGV0IG1vZHVsZUNhY2hlID0ge307XG4gICAgbGV0IHBhcml0eUNhY2hlID0ge307XG5cbiAgICBjb25zdCBtb2R1bGVBcmNoZXR5cGVDYWNoZSA9IHtcbiAgICAgIF9vcHM6IFtdLFxuXG4gICAgICBnZXQoaWQpIHtcbiAgICAgICAgaWYgKG1vZHVsZUNhY2hlW2lkXSAmJiAhbW9kdWxlQ2FjaGVbaWRdLmludmFsaWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZUNhY2hlW2lkXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vZHVsZUNhY2hlW2lkXSA9IEpTT04ucGFyc2UobW9kdWxlQ2FjaGVbaWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZHVsZUNhY2hlW2lkXTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0KGlkLCBpdGVtKSB7XG4gICAgICAgIG1vZHVsZUNhY2hlW2lkXSA9IGl0ZW07XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgdGhpcy5fb3BzLnB1c2goaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZHVsZUNhY2hlW2lkXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlQ2FjaGVbaWRdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbW9kdWxlQ2FjaGVbaWRdID0gSlNPTi5wYXJzZShtb2R1bGVDYWNoZVtpZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2R1bGVDYWNoZVtpZF0uaW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgbW9kdWxlQ2FjaGVbaWRdLmludmFsaWRSZWFzb24gPSAnb3ZlcndyaXR0ZW4nO1xuXG4gICAgICAgICAgdGhpcy5fb3BzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvcGVyYXRpb25zKCkge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMuX29wcy5tYXAoaWQgPT4gKHtcbiAgICAgICAgICBrZXk6IHJlbGF0ZU5vcm1hbE1vZHVsZUlkKGNvbXBpbGVyLCBpZCksXG4gICAgICAgICAgdmFsdWU6IF90aGlzLmdldChpZCkgfHwgbnVsbCxcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9vcHMubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIG9wcztcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbXBpbGVySG9va3MuX2hhcmRTb3VyY2VBcmNoZXR5cGVSZWdpc3Rlci5jYWxsKFxuICAgICAgJ01vZHVsZScsXG4gICAgICBtb2R1bGVBcmNoZXR5cGVDYWNoZSxcbiAgICApO1xuXG4gICAgbGV0IG1vZHVsZUNhY2hlU2VyaWFsaXplcjtcblxuICAgIGNvbXBpbGVySG9va3MuX2hhcmRTb3VyY2VDcmVhdGVTZXJpYWxpemVyLnRhcChcbiAgICAgICdIYXJkU291cmNlIC0gTW9kdWxlQ2FjaGUnLFxuICAgICAgKGNhY2hlU2VyaWFsaXplckZhY3RvcnksIGNhY2hlRGlyUGF0aCkgPT4ge1xuICAgICAgICBtb2R1bGVDYWNoZVNlcmlhbGl6ZXIgPSBjYWNoZVNlcmlhbGl6ZXJGYWN0b3J5LmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogJ21vZHVsZScsXG4gICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgIGNhY2hlRGlyUGF0aCxcbiAgICAgICAgICBhdXRvUGFyc2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29tcGlsZXJIb29rcy5faGFyZFNvdXJjZVJlc2V0Q2FjaGUudGFwKCdIYXJkU291cmNlIC0gTW9kdWxlQ2FjaGUnLCAoKSA9PiB7XG4gICAgICBtb2R1bGVDYWNoZSA9IHt9O1xuICAgIH0pO1xuXG4gICAgY29tcGlsZXJIb29rcy5faGFyZFNvdXJjZVJlYWRDYWNoZS50YXBQcm9taXNlKFxuICAgICAgJ0hhcmRTb3VyY2UgLSBNb2R1bGVDYWNoZScsXG4gICAgICAoeyBjb250ZXh0S2V5cywgY29udGV4dE5vcm1hbE1vZHVsZUlkLCBjb3B5V2l0aERlc2VyIH0pID0+XG4gICAgICAgIG1vZHVsZUNhY2hlU2VyaWFsaXplclxuICAgICAgICAgIC5yZWFkKClcbiAgICAgICAgICAudGhlbihfbW9kdWxlQ2FjaGUgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX21vZHVsZUNhY2hlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnX19oYXJkU291cmNlX3Bhcml0eVRva2VuJykpIHtcbiAgICAgICAgICAgICAgICBwYXJpdHlDYWNoZVtrZXldID0gX21vZHVsZUNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9tb2R1bGVDYWNoZVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfbW9kdWxlQ2FjaGU7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihjb250ZXh0S2V5cyhjb21waWxlciwgY29udGV4dE5vcm1hbE1vZHVsZUlkKSlcbiAgICAgICAgICAudGhlbihjb3B5V2l0aERlc2VyLmJpbmQobnVsbCwgbW9kdWxlQ2FjaGUpKSxcbiAgICApO1xuXG4gICAgY29tcGlsZXJIb29rcy5faGFyZFNvdXJjZVBhcml0eUNhY2hlLnRhcChcbiAgICAgICdIYXJkU291cmNlIC0gTW9kdWxlQ2FjaGUnLFxuICAgICAgcGFyaXR5Um9vdCA9PiB7XG4gICAgICAgIHBhcml0eUNhY2hlRnJvbUNhY2hlKCdNb2R1bGUnLCBwYXJpdHlSb290LCBwYXJpdHlDYWNoZSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb21waWxlckhvb2tzLmNvbXBpbGF0aW9uLnRhcCgnSGFyZFNvdXJjZSAtIE1vZHVsZUNhY2hlJywgY29tcGlsYXRpb24gPT4ge1xuICAgICAgY29tcGlsYXRpb24uX19oYXJkU291cmNlTW9kdWxlQ2FjaGUgPSBtb2R1bGVDYWNoZTtcbiAgICB9KTtcblxuICAgIGNvbXBpbGVySG9va3MuX2hhcmRTb3VyY2VXcml0ZUNhY2hlLnRhcFByb21pc2UoXG4gICAgICAnSGFyZFNvdXJjZSAtIE1vZHVsZUNhY2hlJyxcbiAgICAgIGNvbXBpbGF0aW9uID0+IHtcbiAgICAgICAgY29uc3QgbW9kdWxlT3BzID0gbW9kdWxlQXJjaGV0eXBlQ2FjaGUub3BlcmF0aW9ucygpO1xuXG4gICAgICAgIGlmICghY29tcGlsYXRpb24uY29tcGlsZXIucGFyZW50Q29tcGlsYXRpb24pIHtcbiAgICAgICAgICAvLyBBZGQgb3BzIHRvIHJlbW92ZSBubyBsb25nZXIgdmFsaWQgbW9kdWxlcy4gSWYgdGhleSB3ZXJlIHJlcGxhY2VkIHdpdGggYVxuICAgICAgICAgIC8vIHVwIHRvIGRhdGUgbW9kdWxlLCB0aGV5IHdpbGwgYWxyZWFkeSBoYXZlIHJlcGxhY2VkIHRoaXMgaXRlbSBzbyB3ZVxuICAgICAgICAgIC8vIHdvbid0IGFjY2lkZW50YWxseSBkZWxldGUgdXAgdG8gZGF0ZSBtb2R1bGVzLlxuICAgICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZUNhY2hlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUl0ZW0gPSBtb2R1bGVDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKGNhY2hlSXRlbSAmJiBjYWNoZUl0ZW0uaW52YWxpZCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaW52YWxpZCcsIGNhY2hlSXRlbS5pbnZhbGlkUmVhc29uKTtcbiAgICAgICAgICAgICAgbW9kdWxlQ2FjaGVba2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgIG1vZHVsZU9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFBhcml0eVdyaXRlT3BzKGNvbXBpbGF0aW9uLCBtb2R1bGVPcHMpO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVDYWNoZVNlcmlhbGl6ZXIud3JpdGUobW9kdWxlT3BzKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUNhY2hlO1xuIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvdHlsZXJhcmJ1cy9kZXYvcHJvdmlkZXIvc3JjIn0=
